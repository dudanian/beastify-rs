<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Web Extensions with Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="01-getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-prerequisites.html"><strong aria-hidden="true">1.1.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="01-initial-setup.html"><strong aria-hidden="true">1.2.</strong> Initial setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-webpack-development.html"><strong aria-hidden="true">1.2.1.</strong> webpack --mode development</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="02-important-concepts.html"><strong aria-hidden="true">2.</strong> Important concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02-mixing-rust.html"><strong aria-hidden="true">2.1.</strong> Mixing Rust functions</a></li><li class="chapter-item expanded "><a href="02-api-bindings.html"><strong aria-hidden="true">2.2.</strong> Browser API bindings</a></li><li class="chapter-item expanded "><a href="02-creating-objects.html"><strong aria-hidden="true">2.3.</strong> Creating Objects</a></li><li class="chapter-item expanded "><a href="02-functions-and-closures.html"><strong aria-hidden="true">2.4.</strong> Handling callbacks: Functions and Closures</a></li><li class="chapter-item expanded "><a href="02-promises-and-futures.html"><strong aria-hidden="true">2.5.</strong> Handling Promises with Futures</a></li></ol></li><li class="chapter-item expanded "><a href="03-putting-it-together.html"><strong aria-hidden="true">3.</strong> Putting it all together</a></li><li class="chapter-item expanded affix "><a href="00-references.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Web Extensions with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>There are a lot of resources out there about using Rust and WASM for web development. However, there is almost nothing out there about using Rust and WASM for web <em>extension</em> development. And in fact, there are currently a few hurdles to get a web extension started with Rust. So I thought I'd go through a simple example to show how to use Rust with web extensions in some more detail.</p>
<p>This book will be structured as a tutorial. I'm going to go through the steps I took while investigating this topic and go into more detail with some of the challenges I faced, either with WASM generally or specifically with web extensions. Feel free to follow along, or just read through the chapters.</p>
<h2><a class="header" href="#disclaimer" id="disclaimer"><em>Disclaimer</em></a></h2>
<p>I am not a web developer. I don't consider myself particularly strong in web tech either. I originally wanted to use Rust and WASM to avoid using JavaScript and webpack at all, but I definitely needed some JavaScript and webpack knowledge to get through this. Basically, forgive me if I make a silly JavaScript mistake or have a weird webpack configuration. This is all still fairly new to me.</p>
<p>Also, don't take this as a &quot;best-practices&quot; without confirming the actual best-practices yourself. This is my own investigation into Rust and WASM, and I'm sure to be doing some less-than-optimal things throughout this book.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>I decided the best place to start with is probably to just rewrite a small, working extension. This way, we know that the extension works and any problems can be directly attributed to my own mistakes and not to the extension.</p>
<p>So I tried to rewrite the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Your_first_WebExtension">Your first extension</a> example from Mozilla in Rust. I say &quot;try&quot; because I ended up giving up on this idea. Despite there being only 1 line of JavaScript, trivially rewritable in Rust, it was <em>not</em> so easy to get the resulting WASM module loaded on the client page.</p>
<p>Basically, the project changed from rewriting some JavaScript in Rust to trying to figure out how <code>fetch</code> works with <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts">content scripts</a>. A problem you can probably tell from my disclaimer that I am woefully unequipped to handle, although it does seem possible. I might revisit this in a &quot;Part 2&quot; down the road, but for now I'm okay with just giving up on content scripts and sending them as JavaScript.</p>
<p>Instead, let's look at <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Your_second_WebExtension">Your second extension</a> instead. While this also has a content script, it also has a <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Browser_actions">browser action</a> which is easier to convert to Rust (this seems to be because <code>html</code> pages like browser actions have an easier time loading multiple resources).</p>
<p>So let's get started!</p>
<h1><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h1>
<p>This guide will assume you have access the following installed:</p>
<ul>
<li>a working Rust install with <code>wasm</code> target</li>
<li><code>wasm-pack</code></li>
<li><code>npm</code></li>
</ul>
<p>In addition, we will be using the following when building:</p>
<ul>
<li><code>web-ext</code></li>
<li><code>webpack</code></li>
</ul>
<p>Also this tutorial exclusively uses Firefox, although it could probably be adapted to work with Chrome.</p>
<h1><a class="header" href="#initial-setup" id="initial-setup">Initial setup</a></h1>
<p>I'm using the <a href="https://github.com/rustwasm/rust-webpack-template">rust-webpack-template</a> as a starting point:</p>
<pre><code class="language-sh">npm init rust-webpack beastify-rs
</code></pre>
<p>From there, I copied all of the example files from <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Your_second_WebExtension">the example extension</a> into the <code>static</code> directory. This should include:</p>
<ul>
<li><code>manifest.json</code> - the extension's manifest</li>
<li><code>choose_beast.html</code> - the browser action page</li>
<li><code>choose_beast.css</code> - the browser action page's style</li>
<li><code>beastify.js</code> - the content script</li>
<li><code>icons</code> - directory containing all the icons</li>
</ul>
<p>The last file, <code>choose_beast.js</code>, was put into the <code>js</code> folder because we are going to be messing with it. Also, make sure you either keep the same directory structure of the example or update all of the reference paths. I will be using slightly different paths than the original example.</p>
<h2><a class="header" href="#hello-world" id="hello-world">&quot;Hello world!&quot;</a></h2>
<p>And finally we want to add our WASM module to the browser action's page. By default it should just log a <code>&quot;Hello world!&quot;</code> when it is loaded. All we need to do is add our <code>index.js</code> to the <code>choose_beast.html</code> file:</p>
<pre><code class="language-html">&lt;body&gt;
  ...
  &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;choose_beast.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>With this, we should be able to compile our extension and confirm that it works. If we run <code>web-ext run -s dist</code> and visit a webpage, the extension should work properly. And if we go to <code>about:debugging</code> -&gt; <code>This Firefox</code> -&gt; <code>Beastify</code> -&gt; <code>Inspect</code> -&gt; <code>Console</code> and then click the extension, we should see <code>&quot;Hello world!&quot;</code> being printed by our WASM when it is loaded. And with that, we have successfully gotten some WASM to run in an extension!</p>
<h1><a class="header" href="#using-webpack---mode-development" id="using-webpack---mode-development">Using <code>webpack --mode development</code></a></h1>
<p>By default, running webpack with <code>--mode development</code> causes errors with our extension when trying to load our WASM module. This is because the unminified JavaScript contains an <code>eval()</code> which is prevented by the default <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/content_security_policy">content security policy</a> for extensions. We can get around this by explicitly allowing <code>eval()</code> in remote scripts by adding the following policy to our <code>manifest.json</code>:</p>
<pre><code class="language-json">{
    // ...
    &quot;content_security_policy&quot;:
      &quot;script-src 'self' 'unsafe-eval'; object-src 'self'&quot;
}
</code></pre>
<p>Of course, this should only be added when developing and be removed before release.</p>
<p>Alternatively, we can just always build in <code>--mode release</code> since that doesn't insert the problematic <code>eval()</code> call.</p>
<h1><a class="header" href="#important-concepts" id="important-concepts">Important concepts</a></h1>
<p>Printing <code>&quot;Hello world!&quot;</code> to the console wasn't the point of this project. We want to rewrite the JavaScript parts entirely in Rust! So let's start by rewriting a simple function in Rust and exporting it to JavaScript. Then we are going to explore some other background knowledge before we rewrite the entire example.</p>
<h1><a class="header" href="#mixing-rust-functions" id="mixing-rust-functions">Mixing Rust functions</a></h1>
<p>The most trivial function in the example is probably <code>beastNameToUrl</code>. It is a small static function that doesn't close over any values. In Rust, it would look something like:</p>
<pre><code class="language-rust ignore">#[wasm_bindgen]
pub fn beast_name_to_url(beast_name: &amp;str) -&gt; JsValue {
    let path = match beast_name {
        &quot;Frog&quot; =&gt; &quot;icons/beasts/frog.jpg&quot;,
        &quot;Snake&quot; =&gt; &quot;icons/beasts/snake.jpg&quot;,
        &quot;Turtle&quot; =&gt; &quot;icons/beasts/turtle.jpg&quot;,
        _ =&gt; return JsValue::null(),
    };

    browser::runtime::get_url(path)
}
</code></pre>
<p>Notice <code>wasm-bindgen</code> can automatically convert our arguments to <code>&amp;str</code>s for us, although it will panic if the JavaScript doesn't end up passing a String value. Also just ignore the browser API function at the bottom for a bit, we will get to that later.</p>
<h2><a class="header" href="#importing-into-javascript" id="importing-into-javascript">Importing into JavaScript</a></h2>
<p>If we wanted to use this function in our JavaScript, we have to import it. Our WASM code is compiled into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript module</a>, which means we can <code>import</code> certain <code>export</code>ed functions from it. Marking our function as <code>pub</code> will automatically add it to our list of exported functions.</p>
<p>One way we can import our function is to wrap the entire <code>choose_beast.js</code> in an async <a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">IIFE</a> with a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">dynamic import</a> to load our module. If you look at <code>index.js</code>, you will see that the template is already loading our WASM module dynamically.</p>
<p>All we need to do is remove <code>index.js</code> from <code>choose_beast.html</code> (we previously added it) and add the following around our <code>choose_beast.js</code> file instead:</p>
<pre><code class="language-js">(async () =&gt; {
const { beast_name_to_url } = await import(&quot;../pkg&quot;);
// ...
})();
</code></pre>
<p>This will dynamically import our module and get a handle for our function from WASM. Then we can update the original code to use our function instead of the JavaScript version. Our final version of the extension won't use this wrapper since everything will be written in Rust, but it is convenient for converting things slowly.</p>
<h1><a class="header" href="#browser-api-bindings-or-lack-thereof" id="browser-api-bindings-or-lack-thereof">Browser API bindings (or lack thereof)</a></h1>
<p>Let's back up for a second and talk about JavaScript APIs and Rust bindings. <code>wasm-bindgen</code> is awesome and has two important crates for accessing JavaScript APIs:</p>
<ul>
<li><code>js-sys</code> - bindings for all global APIs (i.e. standard ECMAScript)</li>
<li><code>web-sys</code> - bindings for all of the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API">Web APIs</a> (i.e. APIs given a <code>window</code>)</li>
</ul>
<p>But what it <em>doesn't</em> provide is bindings for <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API">JavaScript APIs for web extensions</a>. And since we are writing a web extension, we kind of need these APIs.</p>
<p>I'm not sure why <code>wasm-bindgen</code> decided not to provide bindings for browser APIs in addition to the others, but I would assume it is because of <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Chrome_incompatibilities">the incompatibilities between the implementations on Firefox and Chrome</a>. Or maybe they just forgot. Either way, we just have to provide our own bindings.</p>
<h2><a class="header" href="#our-bindings" id="our-bindings">Our bindings</a></h2>
<p>There are a few ways we could have written our bindings, for example creating <code>type</code>s for our namespaces, but I decided to go with a simple nested module approach which more or less looks like:</p>
<pre><code class="language-rust ignore">pub mod browser {
    pub mod runtime {
        #[wasm_bindgen]
        extern &quot;C&quot; {
            #[wasm_bindgen(js_namespace = [&quot;browser&quot;, &quot;runtime&quot;], js_name = getURL)]
            pub fn get_url(path: &amp;str) -&gt; JsValue;
        }
    }
}
</code></pre>
<p>Logically, Rust modules perform a similar function to JavaScript namespaces: housing other namespaces and/or functions. The bad part about this approach is that we end up with a lot of nested boilerplate code, but that's life.</p>
<p>If we look at the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/getURL"><code>getURL</code> documentation</a>, we can see that it expects the input argument to be a <code>string</code> and returns a <code>string</code>. In the above example, I made the input parameter a <code>&amp;str</code> so that we can use it with raw Rust values instead of having to convert them to <code>JsValue</code>s first. However, I kept the output as a <code>JsValue</code> since we will not be directly using this value but passing it on to another API function later. It could also be written to return a <code>String</code> since <code>wasm-bindgen</code> will automatically convert the <code>JsValue</code> to a <code>String</code> for us, but this conversion is not free, and writing it this way prevents a needless conversion from <code>JsValue</code> -&gt; <code>String</code> -&gt; <code>JsValue</code>.</p>
<p>In the end, a JavaScript call like:</p>
<pre><code class="language-js">let url = browser.runtime.getURL(&quot;somepath&quot;);
</code></pre>
<p>can now be written in Rust like:</p>
<pre><code class="language-rust ignore">let url: JsValue = browser::runtime::get_url(&quot;somepath&quot;);
</code></pre>
<h1><a class="header" href="#creating-objects-the-first-hurdle" id="creating-objects-the-first-hurdle">Creating <code>Object</code>s: the first hurdle</a></h1>
<p>A lot of the web extension APIs use generic objects to pass parameters. For example:</p>
<pre><code class="language-js">let details = {active: true, currentWindow: true}
browser.tabs.query(details)
</code></pre>
<p>So we obviously need to be able to create generic objects in Rust to pass to these API functions. Originally, I thought you would be able to write something like:</p>
<pre><code class="language-rust ignore">let details = Object::new();
details.set(&quot;active&quot;, true);
details.set(&quot;currentWindow&quot;, true);
</code></pre>
<p>But as it turns out, <code>Object</code> doesn't have a <code>set</code> method. And neither does <code>JsValue</code>. They only have getters. So how do we create objects? Or alternatively set properties? Well, this is actually <a href="https://rustwasm.github.io/docs/wasm-bindgen/reference/accessing-properties-of-untyped-js-values.html">covered in the manual</a>, even if the title of the page is somewhat misleading in my opinion since I wanted to <em>set</em> properties rather than access them.</p>
<h2><a class="header" href="#setting-properties" id="setting-properties">Setting properties</a></h2>
<p>Basically, my approach above wasn't too far off. Instead of using a <code>set</code> method, you have to use the <em>much</em> more verbose <a href="https://docs.rs/js-sys/0.3.45/js_sys/Reflect/fn.set.html"><code>js_sys::Reflect::set</code></a> API:</p>
<pre><code class="language-rust ignore">let details = Object::new();
js_sys::Reflect::set(&amp;details, &amp;JsValue::from_str(&quot;active&quot;), &amp;JsValue::from_bool(true)).unwrap();
js_sys::Reflect::set(&amp;details, &amp;JsValue::from_str(&quot;currentWindow&quot;), &amp;JsValue::from_bool(true)).unwrap();
</code></pre>
<p>Alternatively, we could have created a <code>serde</code>-able <code>struct</code> and used <code>JsValue::from_serde</code>, but from what I have read, using <code>JsValue::from_serde</code> is currently <em>very</em> expensive.</p>
<p>I'm still not completely satisfied with this approach since we aren't preallocating space and each call to <code>js_sys::Reflect::set</code> calls back to JS-land. It almost seems like it would be better to just create some <code>const</code>s in JavaScript and import them into Rust. But my goal for this extension is to be completely contained in Rust. So while importing from JS might be better, I will hold off for now.</p>
<h1><a class="header" href="#handling-callbacks-functions-and-closures" id="handling-callbacks-functions-and-closures">Handling callbacks: <code>Function</code>s and <code>Closure</code>s</a></h1>
<p>The next big hurdle is how to create a simple callback function. Which again is <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/closures.html">covered in the manual</a>. In general, if we want to create a callback like:</p>
<pre><code class="language-js">document.addEventListener(&quot;click&quot;, (e) =&gt; {
    ...
});
</code></pre>
<p>then we have to create a <code>wasm_bindgen::closure::Closure</code> and reference it as a <code>js_sys::Function</code> when we pass it to the API function:</p>
<pre><code class="language-rust ignore">let cb = Closure::wrap(Box::new(move |e| {
    ...
}) as Box&lt;dyn FnMut(JsValue)&gt;);

document
    .add_event_listener_with_callback(&quot;click&quot;, cb.into_js_value().as_ref().unchecked_ref())
    .unwrap();
</code></pre>
<p>Most of the code above is fairly boiler-plate, and the documentation on all of the parts involved will do a much better job of explaining the details than I can. But let's go over some important things to note:</p>
<ul>
<li>the Rust closure (the <code>|| {}</code>, not the <code>Closure</code>) needs to be <code>move</code> because it needs to own everything it references</li>
<li>the <code>Closure</code> needs to wrap a <code>Box</code></li>
<li>the argument types can be further specified using the <code>as Box&lt;dyn FnMut(String, Element, Document)&gt;</code></li>
<li><code>as_ref()</code> returns a reference to <code>JsValue</code></li>
<li><code>unchecked_ref::&lt;Function&gt;()</code> returns a reference to a <code>Function</code></li>
<li>dropping the <code>Closure</code> will invalidate the callback
<ul>
<li>easiest way to avoid this is to pass ownership to JS using <code>forget()</code> or <code>into_js_value()</code></li>
<li>however, these leak memory and should be used with caution</li>
</ul>
</li>
</ul>
<p>Probably the most annoying thing of all of the above is that there is no way to go straight from a <code>Closure</code> to a <code>Function</code>. For some reason, you <em>have</em> to go through <code>JsValue</code>. This isn't a big deal, but seeing as I'm pretty sure the only reason to use <code>Closure</code> is to pass it as a <code>Function</code>, it just seems like an oversight.</p>
<h1><a class="header" href="#handling-promises-with-futures" id="handling-promises-with-futures">Handling <code>Promise</code>s with <code>Future</code>s</a></h1>
<p>Finally, let's talk about handling <code>Promise</code>s in Rust. This should be the last topic before rewriting our extension. At first, if you look at <code>js_sys::Promise</code>'s documentation, you notice that it has a <code>then</code> and a <code>catch</code> function which both take a <code>&amp;Closure</code> as an argument. So I originally thought we would handle them similarly to how you handle function callbacks. For the given JavaScript:</p>
<pre><code class="language-js">function_returning_promise()
.then((arg) =&gt; {
    // ... some anonymous function
})
.catch(error_handler);
</code></pre>
<p>I thought the Rust would look like:</p>
<pre><code class="language-rust ignore">let cb = Closure::wrap(Box::new(move |arg| {
    // ... some anonymous function
}) as Box&lt;dyn FnMut(JsValue)&gt;);

let err = Closure::wrap(Box::new(move |e| {
    error_handler(e)
}) as Box&lt;dyn FnMut(JsValue)&gt;);

function_returning_promise().then(&amp;cb).catch(&amp;err);
cb.forget();
err.forget();
</code></pre>
<p>The above <em>does</em> in fact work in the sens that the <code>Closure</code> will get called by <code>then</code> on success. But oh boy is this wrong. So so wrong. Why you might ask? Well to start out, it is <em>guaranteed</em> to leak memory. Using <code>forget()</code> is essentially telling Rust that it is ok to leak this memory! I have read <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html#method.forget">the documentation</a> a few times now, and it seems like it will <em>not</em> get GC'd by JavaScript automatically like you might expect.</p>
<p>I think this function is basically like telling Rust, &quot;Hey, please don't free this memory. I know we can't reclaim it, but I really <em>really</em> want this function callback to work...&quot;. This can be okay for functions that don't get dynamically created like our initial callback, but is definitely not something we want to do on every click.</p>
<h2><a class="header" href="#once-and-once_into_js" id="once-and-once_into_js"><code>once</code> and <code>once_into_js</code></a></h2>
<p>You also might be thinking that using <code>Closure::once</code> or <code>Closure::once_into_js</code> instead of <code>Closure::wrap</code> will solve this problem since they <em>will</em> free the underlying memory after the function is called. But the problem here is that a <code>Promise</code> will only call <em>one</em> of those two functions: on <code>resolve</code>, the <code>then</code> callback gets called and on <code>reject</code>, the <code>catch</code> callback gets called. Which means while one of the <code>Closure</code>s does get freed, the other is still guaranteed to leak. So <code>Closure::once</code> also does not seem to be the answer.</p>
<h2><a class="header" href="#rust-jsfutures" id="rust-jsfutures">Rust <code>JsFuture</code>s</a></h2>
<p>Instead, Rust provides an alternative way for handling <code>Promise</code>s: <code>Future</code>s, which are really just Rust's way of handling any asynchronous processing.</p>
<p>Also note that <code>Promise</code>s in JavaScript are <em>eager</em> while <code>Promise</code>s/<code>Future</code>s in Rust are <em>lazy</em>. What this means is that creating a <code>Promise</code> in JavaScript is enough to begin execution. However, we need to explicitly start <code>Promise</code>s in Rust, the simplest of which is probably to use <code>wasm_bindgen_futures::spawn_local</code> with an <code>async</code> block:</p>
<pre><code class="language-rust ignore">let f: JsFuture = // get future somehow
spawn_local(async move {
    f.await.unwrap();
});
</code></pre>
<p>Note again that we need a <code>move</code> in most cases like with <code>Closure</code>s. I don't think the move is mandatory in <em>all</em> cases, but it geneally seems like we need it.</p>
<p>So the actual Rust code for handling <code>Promises</code> will generally look like:</p>
<pre><code class="language-rust ignore">let promise = function_returning_promise();
spawn_local(async move {
    match JsFuture::from(promise).await {
        Ok(arg) =&gt; {
            // ... some anonymous function
        },
        Err(arg) =&gt; error_handler(arg),
    }
});
</code></pre>
<p>With this, we are no longer creating unnecessary <code>Closure</code>s and leaking all that memory.</p>
<h1><a class="header" href="#putting-it-all-together" id="putting-it-all-together">Putting it all together</a></h1>
<p>We went over most of the basic concepts to rewrite <code>choose_beast.js</code> in Rust. I'm not going to go over everything here, but you can feel free to check out <a href="https://github.com/dudanian/beastify-rs">my code on Github</a> to see how the final version looks. Or feel free to tackle the rest of the rewrite yourself!</p>
<h1><a class="header" href="#references" id="references">References</a></h1>
<p>I could not have done this project without the plethora of information available on the internet. Here are some of my primary references when working on this project in no particular order:</p>
<h2><a class="header" href="#guides" id="guides">Guides</a></h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Your_second_WebExtension">Your second extension</a></li>
<li><a href="https://rustwasm.github.io/docs/wasm-bindgen/">The wasm-bindgen Guide</a></li>
</ul>
<h2><a class="header" href="#crate-docs" id="crate-docs">Crate docs</a></h2>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/index.html"><code>js-sys</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/index.html"><code>web-sys</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/index.html"><code>wasm-bindgen</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/index.html"><code>wasm-bindgen-futures</code></a></li>
</ul>
<h2><a class="header" href="#projects" id="projects">Projects</a></h2>
<ul>
<li><a href="https://github.com/rustwasm/rust-webpack-template"><code>rust-webpack-template</code></a></li>
<li><a href="https://github.com/willdurand/rustwasm-addon"><code>rustwasm-addon</code></a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
